import {
  FewShotPromptTemplate
} from "./chunk-4UQJOCC2.js";
import {
  AIMessagePromptTemplate,
  BaseChatPromptTemplate,
  ChatMessagePromptTemplate,
  ChatPromptTemplate,
  HumanMessagePromptTemplate,
  MessagesPlaceholder,
  SystemMessagePromptTemplate
} from "./chunk-4ERYE6IB.js";
import {
  Document
} from "./chunk-65XGEAHF.js";
import {
  BaseExampleSelector,
  BasePromptTemplate,
  BaseStringPromptTemplate,
  PromptTemplate,
  StringPromptValue,
  checkValidTemplate,
  parseTemplate,
  renderTemplate
} from "./chunk-WCSKPLNT.js";
import "./chunk-NDDMNZKA.js";
import "./chunk-2BJHWEWB.js";
import "./chunk-UV5CTPV7.js";

// node_modules/langchain/dist/prompts/selectors/conditional.js
var BasePromptSelector = class {
  /**
   * Asynchronous version of `getPrompt` that also accepts an options object
   * for partial variables.
   * @param llm The language model for which to get a prompt.
   * @param options Optional object for partial variables.
   * @returns A Promise that resolves to a prompt template.
   */
  async getPromptAsync(llm, options) {
    const prompt = this.getPrompt(llm);
    return prompt.partial((options == null ? void 0 : options.partialVariables) ?? {});
  }
};
var ConditionalPromptSelector = class extends BasePromptSelector {
  constructor(default_prompt, conditionals = []) {
    super();
    Object.defineProperty(this, "defaultPrompt", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "conditionals", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.defaultPrompt = default_prompt;
    this.conditionals = conditionals;
  }
  /**
   * Method that selects a prompt based on a set of conditions. If none of
   * the conditions are met, it returns the default prompt.
   * @param llm The language model for which to get a prompt.
   * @returns A prompt template.
   */
  getPrompt(llm) {
    for (const [condition, prompt] of this.conditionals) {
      if (condition(llm)) {
        return prompt;
      }
    }
    return this.defaultPrompt;
  }
};
function isLLM(llm) {
  return llm._modelType() === "base_llm";
}
function isChatModel(llm) {
  return llm._modelType() === "base_chat_model";
}

// node_modules/langchain/dist/prompts/selectors/LengthBasedExampleSelector.js
function getLengthBased(text) {
  return text.split(/\n| /).length;
}
var LengthBasedExampleSelector = class _LengthBasedExampleSelector extends BaseExampleSelector {
  constructor(data) {
    super(data);
    Object.defineProperty(this, "examples", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: []
    });
    Object.defineProperty(this, "examplePrompt", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "getTextLength", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: getLengthBased
    });
    Object.defineProperty(this, "maxLength", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 2048
    });
    Object.defineProperty(this, "exampleTextLengths", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: []
    });
    this.examplePrompt = data.examplePrompt;
    this.maxLength = data.maxLength ?? 2048;
    this.getTextLength = data.getTextLength ?? getLengthBased;
  }
  /**
   * Adds an example to the list of examples and calculates its length.
   * @param example The example to be added.
   * @returns Promise that resolves when the example has been added and its length calculated.
   */
  async addExample(example) {
    this.examples.push(example);
    const stringExample = await this.examplePrompt.format(example);
    this.exampleTextLengths.push(this.getTextLength(stringExample));
  }
  /**
   * Calculates the lengths of the examples.
   * @param v Array of lengths of the examples.
   * @param values Instance of LengthBasedExampleSelector.
   * @returns Promise that resolves with an array of lengths of the examples.
   */
  async calculateExampleTextLengths(v, values) {
    if (v.length > 0) {
      return v;
    }
    const { examples, examplePrompt } = values;
    const stringExamples = await Promise.all(examples.map((eg) => examplePrompt.format(eg)));
    return stringExamples.map((eg) => this.getTextLength(eg));
  }
  /**
   * Selects examples until the total length of the selected examples
   * reaches the maxLength.
   * @param inputVariables The input variables for the examples.
   * @returns Promise that resolves with an array of selected examples.
   */
  async selectExamples(inputVariables) {
    const inputs = Object.values(inputVariables).join(" ");
    let remainingLength = this.maxLength - this.getTextLength(inputs);
    let i = 0;
    const examples = [];
    while (remainingLength > 0 && i < this.examples.length) {
      const newLength = remainingLength - this.exampleTextLengths[i];
      if (newLength < 0) {
        break;
      } else {
        examples.push(this.examples[i]);
        remainingLength = newLength;
      }
      i += 1;
    }
    return examples;
  }
  /**
   * Creates a new instance of LengthBasedExampleSelector and adds a list of
   * examples to it.
   * @param examples Array of examples to be added.
   * @param args Input parameters for the LengthBasedExampleSelector.
   * @returns Promise that resolves with a new instance of LengthBasedExampleSelector with the examples added.
   */
  static async fromExamples(examples, args) {
    const selector = new _LengthBasedExampleSelector(args);
    await Promise.all(examples.map((eg) => selector.addExample(eg)));
    return selector;
  }
};

// node_modules/langchain/dist/prompts/selectors/SemanticSimilarityExampleSelector.js
function sortedValues(values) {
  return Object.keys(values).sort().map((key) => values[key]);
}
var SemanticSimilarityExampleSelector = class _SemanticSimilarityExampleSelector extends BaseExampleSelector {
  constructor(data) {
    super(data);
    Object.defineProperty(this, "vectorStore", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "k", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4
    });
    Object.defineProperty(this, "exampleKeys", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "inputKeys", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.vectorStore = data.vectorStore;
    this.k = data.k ?? 4;
    this.exampleKeys = data.exampleKeys;
    this.inputKeys = data.inputKeys;
  }
  /**
   * Method that adds a new example to the vectorStore. The example is
   * converted to a string and added to the vectorStore as a document.
   * @param example The example to be added to the vectorStore.
   * @returns Promise that resolves when the example has been added to the vectorStore.
   */
  async addExample(example) {
    const inputKeys = this.inputKeys ?? Object.keys(example);
    const stringExample = sortedValues(inputKeys.reduce((acc, key) => ({ ...acc, [key]: example[key] }), {})).join(" ");
    await this.vectorStore.addDocuments([
      new Document({
        pageContent: stringExample,
        metadata: { example }
      })
    ]);
  }
  /**
   * Method that selects which examples to use based on semantic similarity.
   * It performs a similarity search in the vectorStore using the input
   * variables and returns the examples with the highest similarity.
   * @param inputVariables The input variables used for the similarity search.
   * @returns Promise that resolves with an array of the selected examples.
   */
  async selectExamples(inputVariables) {
    const inputKeys = this.inputKeys ?? Object.keys(inputVariables);
    const query = sortedValues(inputKeys.reduce((acc, key) => ({ ...acc, [key]: inputVariables[key] }), {})).join(" ");
    const exampleDocs = await this.vectorStore.similaritySearch(query, this.k);
    const examples = exampleDocs.map((doc) => doc.metadata);
    if (this.exampleKeys) {
      return examples.map((example) => this.exampleKeys.reduce((acc, key) => ({ ...acc, [key]: example[key] }), {}));
    }
    return examples;
  }
  /**
   * Static method that creates a new instance of
   * SemanticSimilarityExampleSelector. It takes a list of examples, an
   * instance of Embeddings, a VectorStore class, and an options object as
   * parameters. It converts the examples to strings, creates a VectorStore
   * from the strings and the embeddings, and returns a new
   * SemanticSimilarityExampleSelector with the created VectorStore and the
   * options provided.
   * @param examples The list of examples to be used.
   * @param embeddings The instance of Embeddings to be used.
   * @param vectorStoreCls The VectorStore class to be used.
   * @param options The options object for the SemanticSimilarityExampleSelector.
   * @returns Promise that resolves with a new instance of SemanticSimilarityExampleSelector.
   */
  static async fromExamples(examples, embeddings, vectorStoreCls, options = {}) {
    const inputKeys = options.inputKeys ?? null;
    const stringExamples = examples.map((example) => sortedValues(inputKeys ? inputKeys.reduce((acc, key) => ({ ...acc, [key]: example[key] }), {}) : example).join(" "));
    const vectorStore = await vectorStoreCls.fromTexts(
      stringExamples,
      examples,
      // metadatas
      embeddings,
      options
    );
    return new _SemanticSimilarityExampleSelector({
      vectorStore,
      k: options.k ?? 4,
      exampleKeys: options.exampleKeys,
      inputKeys: options.inputKeys
    });
  }
};

// node_modules/langchain/dist/prompts/pipeline.js
var PipelinePromptTemplate = class _PipelinePromptTemplate extends BasePromptTemplate {
  static lc_name() {
    return "PipelinePromptTemplate";
  }
  constructor(input) {
    super({ ...input, inputVariables: [] });
    Object.defineProperty(this, "pipelinePrompts", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "finalPrompt", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.pipelinePrompts = input.pipelinePrompts;
    this.finalPrompt = input.finalPrompt;
    this.inputVariables = this.computeInputValues();
  }
  /**
   * Computes the input values required by the pipeline prompts.
   * @returns Array of input values required by the pipeline prompts.
   */
  computeInputValues() {
    const intermediateValues = this.pipelinePrompts.map((pipelinePrompt) => pipelinePrompt.name);
    const inputValues = this.pipelinePrompts.map((pipelinePrompt) => pipelinePrompt.prompt.inputVariables.filter((inputValue) => !intermediateValues.includes(inputValue))).flat();
    return [...new Set(inputValues)];
  }
  static extractRequiredInputValues(allValues, requiredValueNames) {
    return requiredValueNames.reduce((requiredValues, valueName) => {
      requiredValues[valueName] = allValues[valueName];
      return requiredValues;
    }, {});
  }
  /**
   * Formats the pipeline prompts based on the provided input values.
   * @param values Input values to format the pipeline prompts.
   * @returns Promise that resolves with the formatted input values.
   */
  async formatPipelinePrompts(values) {
    const allValues = await this.mergePartialAndUserVariables(values);
    for (const { name: pipelinePromptName, prompt: pipelinePrompt } of this.pipelinePrompts) {
      const pipelinePromptInputValues = _PipelinePromptTemplate.extractRequiredInputValues(allValues, pipelinePrompt.inputVariables);
      if (pipelinePrompt instanceof ChatPromptTemplate) {
        allValues[pipelinePromptName] = await pipelinePrompt.formatMessages(pipelinePromptInputValues);
      } else {
        allValues[pipelinePromptName] = await pipelinePrompt.format(pipelinePromptInputValues);
      }
    }
    return _PipelinePromptTemplate.extractRequiredInputValues(allValues, this.finalPrompt.inputVariables);
  }
  /**
   * Formats the final prompt value based on the provided input values.
   * @param values Input values to format the final prompt value.
   * @returns Promise that resolves with the formatted final prompt value.
   */
  async formatPromptValue(values) {
    return this.finalPrompt.formatPromptValue(await this.formatPipelinePrompts(values));
  }
  async format(values) {
    return this.finalPrompt.format(await this.formatPipelinePrompts(values));
  }
  /**
   * Handles partial prompts, which are prompts that have been partially
   * filled with input values.
   * @param values Partial input values.
   * @returns Promise that resolves with a new PipelinePromptTemplate instance with updated input variables.
   */
  async partial(values) {
    const promptDict = { ...this };
    promptDict.inputVariables = this.inputVariables.filter((iv) => !(iv in values));
    promptDict.partialVariables = {
      ...this.partialVariables ?? {},
      ...values
    };
    return new _PipelinePromptTemplate(promptDict);
  }
  serialize() {
    throw new Error("Not implemented.");
  }
  _getPromptType() {
    return "pipeline";
  }
};
export {
  AIMessagePromptTemplate,
  BaseChatPromptTemplate,
  BaseExampleSelector,
  BasePromptSelector,
  BasePromptTemplate,
  BaseStringPromptTemplate,
  ChatMessagePromptTemplate,
  ChatPromptTemplate,
  ConditionalPromptSelector,
  FewShotPromptTemplate,
  HumanMessagePromptTemplate,
  LengthBasedExampleSelector,
  MessagesPlaceholder,
  PipelinePromptTemplate,
  PromptTemplate,
  SemanticSimilarityExampleSelector,
  StringPromptValue,
  SystemMessagePromptTemplate,
  checkValidTemplate,
  isChatModel,
  isLLM,
  parseTemplate,
  renderTemplate
};
//# sourceMappingURL=langchain_prompts.js.map
